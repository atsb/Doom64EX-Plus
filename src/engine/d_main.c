// Emacs style mode select   -*- C -*-
//-----------------------------------------------------------------------------
//
// Copyright(C) 1993-1997 Id Software, Inc.
// Copyright(C) 1997 Midway Home Entertainment, Inc
// Copyright(C) 2007-2012 Samuel Villarreal
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
//-----------------------------------------------------------------------------
//
//
// DESCRIPTION:
//    DOOM main program (D_DoomMain) and game loop (D_DoomLoop),
//    plus functions to determine game mode (shareware, registered),
//    parse command line parameters, configure game parameters (turbo),
//    and call the startup functions.
//
//-----------------------------------------------------------------------------

#include <SDL3/SDL.h>
#include <stdlib.h>

#include "d_main.h"
#include "doomdef.h"
#include "doomstat.h"
#include "i_sdlinput.h"
#include "sounds.h"
#include "z_zone.h"
#include "w_wad.h"
#include "s_sound.h"
#include "m_misc.h"
#include "m_menu.h"
#include "i_system.h"
#include "g_game.h"
#include "st_stuff.h"
#include "p_setup.h"
#include "con_console.h"
#include "con_cvar.h"
#include "d_devstat.h"
#include "r_wipe.h"
#include "r_main.h"
#include "g_demo.h"
#include "p_saveg.h"
#include "gl_draw.h"
#include "net_client.h"
#include "i_shaders.h"

void D_DoomLoop(void);

static int      pagetic;
static int      screenalpha;
static int      screenalphatext;
static int      creditstage;
static int      creditscreenstage;
static boolean	fadesplash;

boolean        setWindow = true;
int             validcount = 1;
boolean        windowpause = false;
boolean        devparm = false;    // started game with -devparm
boolean        nomonsters = false;    // checkparm of -nomonsters
boolean        respawnparm = false;    // checkparm of -respawn
boolean        respawnitem = false;    // checkparm of -respawnitem
boolean        fastparm = false;    // checkparm of -fast
boolean        BusyDisk = false;
boolean        nolights = false;
skill_t         startskill;
int             startmap;
boolean        autostart = false;
FILE* debugfile = NULL;
//char          wadfile[1024];              // primary wad file
char            mapdir[1024];               // directory of development maps
char            basedefault[1024];          // default file
boolean        rundemo4 = false;    // run demo lump #4?
int             gameflags = 0;
int             compatflags = 0;

void D_CheckNetGame(void);
void D_ProcessEvents(void);
void G_BuildTiccmd(ticcmd_t* cmd);

#define STRPAUSED    "Paused"

CVAR_EXTERNAL(sv_nomonsters);
CVAR_EXTERNAL(sv_fastmonsters);
CVAR_EXTERNAL(sv_respawnitems);
CVAR_EXTERNAL(sv_respawn);
CVAR_EXTERNAL(sv_skill);
CVAR_EXTERNAL(v_maxfps);

//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
event_t            events[MAXEVENTS];
int                eventhead = 0;
int                eventtail = 0;

//
// D_PostEvent
// Called by the I/O functions when input is detected
//

void D_PostEvent(event_t* ev) {
	events[eventhead] = *ev;
	eventhead = (eventhead + 1) & (MAXEVENTS - 1);
}

//
// D_ProcessEvents
// Send all the events of the given timestamp down the responder chain
//

void D_ProcessEvents(void) {
	event_t* ev;

	for (; eventtail != eventhead; eventtail = (eventtail + 1) & (MAXEVENTS - 1)) {
		ev = &events[eventtail];

		// 20120404 villsa - don't do console inputs for demo playbacks
		if (!demoplayback) {
			if (CON_Responder(ev)) {
				continue;    // console ate the event
			}
		}

		if (devparm && !netgame) {
			if (D_DevKeyResponder(ev)) {
				continue;    // dev keys ate the event
			}
		}

		if (M_Responder(ev)) {
			continue;    // menu ate the event
		}

		G_Responder(ev);
	}
}

//
// D_MiniLoop
//

CVAR_EXTERNAL(i_interpolateframes);

extern boolean renderinframe;
extern int      gametime;
extern int      skiptics;

int             frameon = 0;
int             frametics[4];
int             frameskip[4];
int             oldnettics = 0;

int GetLowTic(void);
boolean PlayersInGame(void);

static void D_DrawInterface(void) {
	if (menuactive) {
		M_Drawer();
	}

	CON_Draw();

	if (devparm) {
		D_DeveloperDisplay();
	}

	BusyDisk = false;

	// draw pause pic
	if (paused) {
		Draw_BigText(-1, 64, WHITE, STRPAUSED);
	}
}

static void D_FinishDraw(void) {
	// send out any new accumulation
	NetUpdate();

	I_ShaderUnBind();

	// normal update
	I_FinishUpdate();

	I_EndDisplay();

}

int D_MiniLoop(void (*start)(void), void (*stop)(void),
	void (*draw)(void), int(*tick)(void)) {
	int action = gameaction = ga_nothing;

	if (start) {
		start();
	}

	while (!action) {
		int i = 0;
		int lowtic = 0;
		int entertic = 0;
		int oldentertics = 0;
		int realtics = 0;
		int availabletics = 0;
		int counts = 0;

		windowpause = (menuactive ? true : false);

		// process one or more tics

		// get real tics
		entertic = I_GetTime() / ticdup;
		realtics = entertic - oldentertics;
		oldentertics = entertic;

		if (i_interpolateframes.value) {
			renderinframe = true;

			if (I_StartDisplay()) {
				I_ShaderBind();
				if (draw && !action) {
					draw();
				}
				D_DrawInterface();
				I_ShaderUnBind();
				D_FinishDraw();
			}

			renderinframe = false;
		}

		// get available ticks

		NetUpdate();
		lowtic = GetLowTic();

		availabletics = lowtic - gametic / ticdup;

		// decide how many tics to run

		if (net_cl_new_sync) {
			counts = availabletics;
		}
		else {
			if (realtics < availabletics - 1) {
				counts = realtics + 1;
			}
			else if (realtics < availabletics) {
				counts = realtics;
			}
			else {
				counts = availabletics;
			}

			if (counts < 1) {
				counts = 1;
			}

			frameon++;

			if (!demoplayback) {
				int keyplayer = -1;

				// ideally maketic should be 1 - 3 tics above lowtic
				// if we are consistantly slower, speed up time

				for (i = 0; i < MAXPLAYERS; i++) {
					if (playeringame[i]) {
						keyplayer = i;
						break;
					}
				}

				if (keyplayer < 0) { // If there are no players, we can never advance anyway
					goto drawframe;
				}

				if (consoleplayer == keyplayer) {
					// the key player does not adapt
				}
				else {
					if (maketic <= nettics[keyplayer]) {
						gametime--;
						// I_Printf ("-");
					}

					frameskip[frameon & 3] = (oldnettics > nettics[keyplayer]);
					oldnettics = maketic;

					if (frameskip[0] && frameskip[1] && frameskip[2] && frameskip[3]) {
						skiptics = 1;
						// I_Printf ("+");
					}
				}
			}
		}

		if (counts < 1) {
			counts = 1;
		}

		// wait for new tics if needed

		while (!PlayersInGame() || lowtic < gametic / ticdup + counts) {
			NetUpdate();
			lowtic = GetLowTic();

			if (lowtic < gametic / ticdup) {
				I_Error("D_MiniLoop: lowtic < gametic");
			}

			if (i_interpolateframes.value) {
				renderinframe = true;

				if (I_StartDisplay()) {
					I_ShaderBind();
					if (draw && !action) {
						draw();
					}
					D_DrawInterface();
					I_ShaderUnBind();
					D_FinishDraw();
				}

				renderinframe = false;
			}

			// Don't stay in this loop forever.  The menu is still running,
			// so return to update the screen

			if (I_GetTime() / ticdup - entertic > 0) {
				goto drawframe;
			}

			if (!i_interpolateframes.value) {
				// use this to not peg CPU with an active loop when interpolation is disabled.
				// when interpolation is enabled, this is taken care of by fps limit (vsync off) or vsync on
				// 
				// interpolation disabled seem to always result in a constant framerate of 60 fps (2 * TICRATE)
				SDL_Delay(1);
			}
		}

		// run the count * ticdup tics
		while (counts--) {
			for (i = 0; i < ticdup; i++) {
				// check that there are players in the game.  if not, we cannot
				// run a tic.

				if (!PlayersInGame()) {
					break;
				}

				if (gametic / ticdup > lowtic) {
					I_Error("gametic>lowtic");
				}

				if (i_interpolateframes.value) {
					I_GetTime_SaveMS();
				}

				G_Ticker();

				if (tick) {
					action = tick();
				}

				if (gameaction != ga_nothing) {
					action = gameaction;
				}

				gametic++;

				// modify command for duplicated tics
				if (i != ticdup - 1) {
					ticcmd_t* cmd;
					int buf;
					int j;

					buf = (gametic / ticdup) % BACKUPTICS;
					for (j = 0; j < MAXPLAYERS; j++) {
						cmd = &netcmds[j][buf];
						cmd->chatchar = 0;
						if (cmd->buttons & BT_SPECIAL) {
							cmd->buttons = 0;
						}
					}
				}
			}

			NetUpdate();   // check for new console commands
		}

	drawframe:
		S_UpdateSounds();

		// Update display, next frame, with current state.
		if (i_interpolateframes.value) {
			if (!I_StartDisplay()) {
				goto freealloc;
			}
		}

		I_ShaderBind();
		if (draw && !action) {
			draw();
		}
		D_DrawInterface();
		I_ShaderUnBind();
		D_FinishDraw();
	freealloc:

		// force garbage collection
		Z_FreeAlloca();
	}

	gamestate = GS_NONE;

	if (stop) {
		stop();
	}

	return action;
}

//
// Title_Drawer
//

static void Title_Drawer(void) {
	GL_ClearView(0xFF000000);
	Draw_GfxImageTitle(58, 50, "TITLE", WHITEALPHA(0x64), true);
}

//
// Title_Ticker
//

static int Title_Ticker(void) {
	if (mainmenuactive) {
		if ((gametic - pagetic) >= (TICRATE * 30)) {
			return 1;
		}
	}
	else {
		if (gametic != pagetic) {
			pagetic = gametic;
		}
	}

	return 0;
}

//
// Title_Start
//

static void Title_Start(void) {
	gameaction = ga_nothing;
	pagetic = gametic;
	usergame = false;   // no save / end game here
	paused = false;
	allowclearmenu = false;

	S_StartMusic(W_GetNumForName("MUSTITLE"));
	M_StartMainMenu();
}

//
// Title_Stop
//

static void Title_Stop(void) {
	mainmenuactive = false;
	menuactive = false;
	allowmenu = false;
	allowclearmenu = true;

	WIPE_FadeScreen(8);
	S_StopMusic();
}

static void Legal_Drawer(void) {
	GL_ClearView(0xFF000000);
	Draw_GfxImageLegal(32, 72, "USLEGAL", WHITE, true);
}

static void PhotoSensWarning_Drawer(void) {
	GL_ClearView(0xFF000000);
	Draw_GfxImageLegal(32, 72, PHSENSW_LUMPNAME, WHITE, true);
}

//
// Splash_Ticker
//

static int Splash_Ticker(void) {
	if ((gametic - pagetic) >= (TICRATE * 5)) {
		if (fadesplash) {
			WIPE_FadeScreen(6);
		}
		return 1;
	}

	return 0;
}

//
// Credits_Drawer
//

static void Credits_Drawer(void) {
	GL_ClearView(0xFF000000);

	switch (creditscreenstage) {
	case 0:
		Draw_GfxImage(72, 24, "IDCRED1",
			D_RGBA(255, 255, 255, (byte)screenalpha), true);

		Draw_GfxImage(40, 40, "IDCRED2",
			D_RGBA(255, 255, 255, (byte)screenalphatext), true);
		break;

	case 1:
		Draw_GfxImage(16, 80, "WMSCRED1",
			D_RGBA(255, 255, 255, (byte)screenalpha), true);

		Draw_GfxImage(32, 24, "WMSCRED2",
			D_RGBA(255, 255, 255, (byte)screenalphatext), true);
		break;

	case 2:
		Draw_GfxImageInter(64, 30, "EVIL",
			D_RGBA(255, 255, 255, (byte)screenalpha), true);
		break;
	}
}

//
// Credits_Ticker
//

static int Credits_Ticker(void) {
	switch (creditstage) {
	case 0:
		if (screenalpha < 0xff) {
			screenalpha = MIN(screenalpha + 8, 0xff);
		}
		else {
			creditstage = 1;
		}
		break;

	case 1:
		if (screenalphatext < 0xff) {
			screenalphatext = MIN(screenalphatext + 8, 0xff);
		}
		else {
			creditstage = 2;
		}
		break;

	case 2:
		if ((gametic - pagetic) >= (TICRATE * 6)) {
			screenalpha = MAX(screenalpha - 8, 0);
			screenalphatext = MAX(screenalphatext - 8, 0);

			if (screenalpha <= 0) {
				creditstage = 3;
				creditscreenstage++;
			}
		}
		break;

	case 3:
		if (creditscreenstage >= 3) {
			return 1;
		}

		screenalpha = 0;
		screenalphatext = 0;
		creditstage = 0;
		pagetic = gametic;

		break;
	}

	return 0;
}

//
// Credits_Start
//

static void Credits_Start(void) {
	screenalpha = 0;
	screenalphatext = 0;
	creditstage = 0;
	creditscreenstage = 0;
	pagetic = gametic;
	allowmenu = false;
	menuactive = false;
	usergame = false;   // no save / end game here
	paused = false;
	gamestate = GS_SKIPPABLE;
}

//
// D_SplashScreen
//


//
// D_RunDemos
//
static int D_RunDemos(void)
{
    const char* candidates[][3] = {
        { "DEMO1LMP", "DEMO1", NULL },
        { "DEMO2LMP", "DEMO2", NULL },
        { "DEMO3LMP", "DEMO3", NULL },
    };
    const int maps[] = { 3, 9, 17 };
    int i;

    for (i = 0; i < 3; i++)
    {
        const char* name0 = candidates[i][0];
        const char* name1 = candidates[i][1];
        
		if (W_CheckNumForName(name0) >= 0 || W_CheckNumForName(name1) >= 0)
        {
            const char* pick = (W_CheckNumForName(name0) >= 0) ? name0 : name1;
            int exit = D_RunDemo((char*)pick, sk_medium, maps[i]);
            if (exit == ga_exitdemo)
                return exit;

            if (gameaction != ga_nothing)
                return gameaction;
        }
    }

    return ga_nothing;
}

static int D_ShowSplash(void (*draw)(void), int(*tick)(void), boolean fade) {

	screenalpha = 0xff;
	allowmenu = false;
	menuactive = false;

	gamestate = GS_SKIPPABLE;
	pagetic = gametic;
	gameaction = ga_nothing;
	fadesplash = fade;

	return D_MiniLoop(NULL, NULL, draw, tick);
}

static void D_SplashScreen(void) {

	if (gameaction || netgame) return;
	
	if (D_ShowSplash(Legal_Drawer, Splash_Ticker, false) != ga_title &&
		D_ShowSplash(PhotoSensWarning_Drawer, Splash_Ticker, true) != ga_title) {
		G_RunTitleMap();
		gameaction = ga_title;
	}
}

//
// D_DoomLoop
// Main game loop
//

void D_DoomLoop(void) {
	int exit;

	if (netgame) {
		gameaction = ga_newgame;
	}

	exit = gameaction;

	while (1) {
		exit = D_MiniLoop(Title_Start, Title_Stop, Title_Drawer, Title_Ticker);

		if (exit == ga_newgame || exit == ga_loadgame) {
			G_RunGame();
		}
		else {
			/*  Don't run demos as they do not play properly and crash the game
        {
            int demoexit = D_RunDemos();
            if (demoexit == ga_exitdemo) {
                return;
            }
            if (gameaction == ga_title) {
                continue;
            }
        }
			*/
    
			D_MiniLoop(Credits_Start, NULL, Credits_Drawer, Credits_Ticker);

			if (gameaction == ga_title) {
				continue;
			}
		}
	}
}

//      print title for every printed line
char title[128];

//
// Find a Response File
//

#define MAXARGVS 100

static void FindResponseFile(void) {
	int i;

	for (i = 1; i < myargc; i++) {
		if (myargv[i][0] == '@') {
			FILE* handle;
			int     size;
			int     k;
			int     index;
			int     indexinfile;
			char* infile;
			char* file;
			char* moreargs[20];
			char* firstargv;

			// READ THE RESPONSE FILE INTO MEMORY
			handle = fopen(&myargv[i][1], "rb");
			if (!handle) {
				//                I_Warnf (IWARNMINOR, "\nNo such response file!");
				exit(1);
			}
			I_Printf("Found response file %s!\n", &myargv[i][1]);
			fseek(handle, 0, SEEK_END);
			size = ftell(handle);
			fseek(handle, 0, SEEK_SET);
			file = (char*)malloc(size);
			fread(file, size, 1, handle);
			fclose(handle);

			// KEEP ALL CMDLINE ARGS FOLLOWING @RESPONSEFILE ARG
			for (index = 0, k = i + 1; k < myargc; k++) {
				moreargs[index++] = myargv[k];
			}

			firstargv = myargv[0];
			myargv = (char**)malloc(sizeof(char*) * MAXARGVS);
			dmemset(myargv, 0, sizeof(char*) * MAXARGVS);
			myargv[0] = firstargv;

			infile = file;
			indexinfile = k = 0;
			indexinfile++;  // SKIP PAST ARGV[0] (KEEP IT)
			do {
				myargv[indexinfile++] = infile + k;
				while (k < size &&
					((*(infile + k) >= ' ' + 1) && (*(infile + k) <= 'z'))) {
					k++;
				}
				*(infile + k) = 0;
				while (k < size &&
					((*(infile + k) <= ' ') || (*(infile + k) > 'z'))) {
					k++;
				}
			} while (k < size);

			for (k = 0; k < index; k++) {
				myargv[indexinfile++] = moreargs[k];
			}
			myargc = indexinfile;

			// DISPLAY ARGS
			for (k = 1; k < myargc; k++) {
				I_Printf("%d command-line args: %s\n", myargc, myargv[k]);
			}

			break;
		}
	}
}

//
// D_Init
//

static void D_Init(void) {
	int     p;

	FindResponseFile();

	nomonsters = M_CheckParm("-nomonsters");
	respawnparm = M_CheckParm("-respawn");
	respawnitem = M_CheckParm("-respawnitem");
	fastparm = M_CheckParm("-fast");

	if ((p = M_CheckParm("-setvars"))) {
		p++;

		while (p != myargc && myargv[p][0] != '-') {
			char* name;
			char* value;

			name = myargv[p++];
			value = myargv[p++];

			CON_CvarSet(name, value);
		}
	}

	if (M_CheckParm("-deathmatch")) {
		deathmatch = 1;
	}

	// get skill / episode / map from parms
	startskill = sk_medium;
	startmap = 1;
	autostart = false;

	p = M_CheckParm("-skill");
	if (p && p < myargc - 1) {
		startskill = myargv[p + 1][0] - '1';
		autostart = true;
		gameaction = ga_newgame;
	}

	p = M_CheckParm("-timer");
	if (p && p < myargc - 1 && deathmatch) {
		int     time;
		time = datoi(myargv[p + 1]);
		I_Printf("Levels will end after %d minute\n", time);

		if (time > 1) {
			I_Printf("s");
		}

		I_Printf(".\n");
	}

	p = M_CheckParm("-warp");
	if (p && p < myargc - 1) {
		autostart = true;
		startmap = datoi(myargv[p + 1]);
		gameaction = ga_newgame;
	}

	// set server cvars
	CON_CvarSetValue(sv_skill.name, (float)startskill);
	CON_CvarSetValue(sv_respawn.name, (float)respawnparm);
	CON_CvarSetValue(sv_respawnitems.name, (float)respawnitem);
	CON_CvarSetValue(sv_fastmonsters.name, (float)fastparm);
	CON_CvarSetValue(sv_nomonsters.name, (float)nomonsters);

	p = M_CheckParm("-loadgame");
	if (p && p < myargc - 1) {
		char *filepath = P_GetSaveGameName(myargv[p + 1][0] - '0');
		G_LoadGame(filepath);
		free(filepath);
		autostart = true; // 20120105 bkw: this was missing
	}

	if (M_CheckParm("-nogun")) {
		ShowGun = false;
	}
}

//
// D_CheckDemo
//

static int D_CheckDemo(void) {

	// Demo recording / playback is broken (crashes) so disable it for now

	/*
	int p;

	// start the apropriate game based on parms
	p = M_CheckParm("-record");

	if (p && p < myargc - 1) {
		G_RecordDemo(myargv[p + 1]);
		return 1;
	}

	p = M_CheckParm("-playdemo");
	if (p && p < myargc - 1) {
		singledemo = true;              // quit after one demo
		G_PlayDemo(myargv[p + 1]);
		return 1;
	}
	*/

	return 0;
}

void D_CheckDataFileFound(char* filename) {

	char *path = I_FindDataFile(filename); // must not free

	if (!path) {
		I_Error("Required game data file not found: %s.\n\nPlease install the DOOM 64 Remaster "
			"on GOG or Steam, or copy file %s to %s",
			filename,
			filename,
			I_GetUserDir());
	}
}


// check availability of data files and immediately exit with message box if not found
void D_CheckDataFilesFound(void) {
	D_CheckDataFileFound(IWAD_FILENAME);
	D_CheckDataFileFound(KPF_FILENAME);
	if (!M_CheckParm("-nosound") || !M_CheckParm("-nomusic")) {
		D_CheckDataFileFound(DLS_FILENAME);
	}
}

//
// D_DoomMain
//

void D_DoomMain(void) {

	devparm = M_CheckParm("-devparm");

	// init subsystems

	I_Printf("Z_Init: Init Zone Memory Allocator\n");
	Z_Init();

	I_Printf("CON_Init: Init Game Console\n");
	CON_Init();

	D_CheckDataFilesFound();

	I_Printf("G_Init: Setting up game input and commands\n");
	G_Init();

	I_Printf("M_LoadDefaults: Loading game configuration\n");
	M_LoadDefaults();

	I_Printf("I_Init: Setting up machine state.\n");
	I_Init();

	I_Printf("W_Init: Init WADfiles.\n");
	W_Init();

	I_Printf("D_Init: Init DOOM parameters\n");
	D_Init();

	I_Printf("R_Init: Init DOOM refresh daemon.\n");
	R_Init();

	I_Printf("P_Init: Init Playloop state.\n");
	P_Init();

	I_Printf("M_Init: Init miscellaneous info.\n");
	M_Init();

	I_Printf("NET_Init: Init network subsystem.\n");
	NET_Init();

	I_Printf("S_Init: Setting up sound.\n");
	S_Init();

	I_Printf("D_CheckNetGame: Checking network game status.\n");
	D_CheckNetGame();

	I_Printf("ST_Init: Init status bar.\n");
	ST_Init();

	I_Printf("GL_Init: Init OpenGL\n");
	GL_Init();

	// garbage collection
	Z_FreeAlloca();

	if (!D_CheckDemo()) {
		if (!autostart) {
			// start legal screen and title map stuff
			D_SplashScreen();
		}
		else {
			G_RunGame();
		}
	}

	D_DoomLoop();   // never returns
}
